/*
  P5732 - 输出杨辉三角的前 n 行

  说明：读入一个整数 n (1 <= n <= 20)，输出杨辉三角的前 n 行。
  每行数字以空格分隔，行内不应有尾随空格；行与行之间以换行分隔。

  实现思路：使用一个长度为 21 的数组 row 存储当前行（下标从 0 开始）。
  初始化为全 0；对于每一行 i（从 0 到 n-1）：
    - 将 row[0] 设为 1（每行第一个元素恒为 1）。
    - 从右向左更新 row：对于 j = i..1，执行 row[j] = row[j] + row[j-1]，
      这样可以原地把上一行转换为当前行（避免辅助数组）。
    - 依次打印 row[0..i]，元素之间用单个空格分隔，末尾不输出多余空格。

  说明边界：n 最大为 20，因此 long long 足够存放杨辉三角的值（第 20 行的最大值为 C(19,9)=92378）。
*/

#include <stdio.h>

int main(void) {
    int n;
    if (scanf("%d", &n) != 1) return 0;
    /*
     row[k] 存储当前行的第 k 个元素（0-based）。
     数组长度为 21，保证能处理 n<=20 的情况（下标 0..20）。
    */
    long long row[21] = {0};

    for (int i = 0; i < n; ++i) {
        /* 每行第一个元素始终为 1 */
        row[0] = 1;

        /*
         从右到左更新，使得 row[j] = old_row[j] + old_row[j-1]
         注意循环的上界为 i，因为第 i 行有 i+1 个元素（下标 0..i）
        */
        for (int j = i; j >= 1; --j) {
            row[j] = row[j] + row[j-1];
        }

        /* 打印当前行，元素间以单个空格分隔（行尾无多余空格） */
        for (int j = 0; j <= i; ++j) {
            if (j) putchar(' ');
            printf("%lld", row[j]);
        }

        /* 输出换行（最后一行后可不额外输出换行，但大多数 OJ 接受） */
        if (i != n-1) putchar('\n');
    }

    return 0;
}
