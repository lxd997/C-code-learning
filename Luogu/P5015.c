#include <stdio.h>
#include <stdlib.h>
#include <string.h>

/*
  P5015 标题统计（NOIP 2018 普及组）

  题目要求：输入文件只有一行，一个字符串 s（可能包含大、小写字母、数字、空格，行末有换行符）。
  输出：字符串 s 中除了空格和换行符外的字符个数。

  实现要点：
  - 需要读取一整行（包含空格），因此使用 fgets 而不是 scanf("%s")，后者遇空格会截断。
  - fgets 会把行末的换行符 '\n' 一并读入（如果缓冲区足够），因此统计时要跳过 '\n'，并考虑 Windows 的 '\r'（回车）字符。
  - 为稳妥起见（题目说明 |s| <= 10^5），缓冲区大小设为 100005，保证不会溢出；也可以改用动态分配。
*/

int main(void) {
    /*
     * 定义缓冲区读取整行：
     * - 大小按题目保证增加为 100005，以满足最大长度 10^5 的情况（多留 1 字节放 '\0'）。
     * - 使用静态数组放在栈上，对于 100k 字节在大多数环境是安全的；若担心可使用 malloc。
     */
    char s[100005];

    /*
     * fgets 用法：fgets(buffer, size, stdin)
     * - 从标准输入读取一行（包括空格），最多读 size-1 个字符，最后以 '\0' 结尾。
     * - 读取到换行符时会把换行符也放入缓冲区（例如 "abc\n"），如果缓冲区容量不足，fgets 会读入部分并终止。
     * - 如果返回 NULL 表示读取失败或遇到 EOF，此时直接退出程序（题目保证输入存在，这里是保险检查）。
     */
    if (!fgets(s, sizeof(s), stdin)) return 0;

    /*
     * 统计有效字符：题目不计入空格和换行符。这里逐字符遍历字符串，遇到以下字符跳过：
     *  - 空格 ' '
     *  - 换行 '\n'（Unix/ Linux 的行结束符）
     *  - 回车 '\r'（Windows 的 CRLF 行结束符中可能出现）
     * 使用 size_t 作为索引类型以匹配 strlen 返回类型并避免签名问题。
     */
    int cnt = 0;
    for (size_t i = 0; s[i] != '\0'; ++i) {
        char ch = s[i];
        // 跳过空格或换行符或回车（不计入统计）
        if (ch == ' ' || ch == '\n' || ch == '\r') continue;
        ++cnt; // 其他字符均计数
    }

    /* 输出结果：按照题目要求，打印一个整数并以换行结束 */
    printf("%d\n", cnt);
    return 0;
}

